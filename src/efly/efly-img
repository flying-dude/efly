#!/usr/bin/python

usage = f"""
Usage: efly img [options]

Create raw disk images for live systems bootable from a USB flash drive.
The live system has persistent storage and will retain changes among reboots.

General Options:
  -h --help                  Show this screen.
  --out <out-dir>            Choose output directory instead of out/ inside current working directory.
  --profile <profile-dir>    Use a custom profile instead of default profile.

  --shell                    Launch an interactive shell after running the postinst script.
                             Useful for doing some manual tweaking or for debuggung.

Size Options:                Unit in M, G or T (KiB, MiB, GiB, TiB resp.) - Example: 128M
  --efi-size <size>          Set size of the EFI boot partition.
  --overlay-size <size>      Set initial size of overlay partition. Will still auto-expand on first boot.
""".lstrip().rstrip()

import os, subprocess, atexit, sys, re, math
from pathlib import Path

script_dir = Path(os.path.dirname(os.path.realpath(__file__)))
profile_dir = script_dir / "img"
out_dir = Path("out")

# colored output, if corresponding python module is available
try:
    import colorama
    from colorama import Fore, Back, Style
    colorama.init()
    yellow = lambda s: Fore.YELLOW + s + Style.RESET_ALL
    green = lambda s: Fore.GREEN + s + Style.RESET_ALL
    red = lambda s: Fore.RED + s + Style.RESET_ALL
    light_cyan = lambda s: Fore.LIGHTCYAN_EX + s + Style.RESET_ALL
    light_green = lambda s: Fore.LIGHTGREEN_EX + s + Style.RESET_ALL
    light_magenta = lambda s: Fore.LIGHTMAGENTA_EX + s + Style.RESET_ALL
    light_red = lambda s: Fore.LIGHTRED_EX + s + Style.RESET_ALL
except ImportError:
    yellow = lambda s: s
    green = lambda s: s
    red = lambda s: s
    light_cyan = lambda s: s
    light_green = lambda s: s
    light_magenta = lambda s: s
    light_red = lambda s: s

def log(prefix, msg):
    print(f"[{prefix}] {msg}")

def info(msg):
    log(yellow("info"), msg)

def error(msg):
    log(light_red("error"), msg)

# https://stackoverflow.com/questions/33341000/extract-numbers-and-size-information-kb-mb-etc-from-a-string-in-python
size_regex = re.compile(r'(\d+(?:\.\d+)?)\s*([bkmgtp]?)', re.IGNORECASE)
size_order = ['b', 'k', 'm', 'g', 't', 'p']
def parse_size(size_string): # parse size string and return size in bytes
    match = size_regex.findall(size_string)
    if not match:
            raise Exception(f'invalid size: "{size_string}"')
    value, unit = match[0]
    unit = unit if unit else "b" # unit is optional. default is byte.
    return int(float(value) * (1024**size_order.index(unit.lower())))

# parse cli
cli_efi_size_M = -1
cli_overlay_size_M = -1
flag_shell = False
args = sys.argv[1:]
while args and args[0].startswith("-"):
    if args[0] == "-v" or args[0] == "--version":
        print(version)
        exit(0)

    if args[0] == "-h" or args[0] == "--help":
        print(usage)
        exit(0)

    if args[0] == "--efi-size":
        if len(args) < 2:
            error('missing argument for cli flag "--efi-size"')
            exit(1)

        try:
            cli_efi_size_B = parse_size(args[1])
            cli_efi_size_M = math.ceil(cli_efi_size_B / 1024 / 1024)
            info(f'will use at least {cli_efi_size_M}MiB for EFI boot partition')
        except Exception as e:
            error(f'invalid efi size: "{args[1]}"')
            exit(1)

        args = args[2:]
        continue

    if args[0] == "--overlay-size":
        if len(args) < 2:
            error('missing argument for cli flag "--overlay-size"')
            exit(1)

        try:
            cli_overlay_size_B = parse_size(args[1])
            cli_overlay_size_M = math.ceil(cli_overlay_size_B / 1024 / 1024)
            info(f'will use at least {cli_overlay_size_M}MiB for overlay partition')
        except Exception as e:
            error(f'invalid overlay size: "{args[1]}"')
            exit(1)

        args = args[2:]
        continue

    if args[0] == "--profile":
        if len(args) < 2:
            error('missing argument for cli flag "--profile"')
            exit(1)
        else:
            profile_dir = Path(args[1])
            args = args[2:]
            continue

    if args[0] == "--out":
        if len(args) < 2:
            error('missing argument for cli flag "--out"')
            exit(1)
        else:
            out_dir = Path(args[1])
            args = args[2:]
            continue

    if args[0] == "--shell":
        flag_shell = True
        args = args[2:]
        continue

    error(f'unknown cli flag: "{args[0]}"')
    exit(1)

# list of required shell commands together with their corresponding packages
cmd2pkg = [
    ("arch-chroot", "arch-install-scripts"),
    ("mkfs.vfat", "dosfstools"),
    ("mkfs.ext4", "e2fsprogs"),
    ("pacstrap", "arch-install-scripts"),
    ("sgdisk", "gptfdisk"),
    ("sudo", "sudo")]

# check for presence of required shell commands
from shutil import which
missing_pkg = False
for cmd, pkg in cmd2pkg:
    if which(cmd) is None:
        error(f"missing shell command '{cmd}'. if running arch linux, install with: pacman --sync {pkg}")
        missing_pkg = True

# abort if we are missing some shell commands
if missing_pkg:
    error("exiting due to missing shell command.")
    exit(1)

# check if config dir is present
if not profile_dir.is_dir():
    error(f'profile folder not present: "{profile_dir}"')
    exit(1)

# check for presence of package list
package_txt = profile_dir / "packages.txt"
if not package_txt.is_file():
    error(f'package file not found: "{packages_txt}"')
    exit(1)

# read and parse list of packages
packages = []
with open(package_txt) as lines:
    for line in lines:
        line = line.rstrip()
        if len(line) == 0:
            continue

        line = line.split('#')[0]
        if len(line) == 0:
            continue

        line = line.split(' ')
        for pkg in line:
            if len(pkg) == 0:
                continue
            packages.append(pkg)

exiting = False
def r(args, ignore_error=False, **kwargs):
    global exiting
    cmd = ' '.join(str(arg) for arg in args)
    log(light_cyan("exec"), cmd)

    returncode = subprocess.run(args, **kwargs).returncode
    if not returncode == 0 and not ignore_error:
        error(f'command failed: {red(cmd)}')

        # exit on error. but don't call exit again, if we are already exiting (this could happen, if we have another error during cleanup).
        if not exiting:
            exiting = True
            exit(1)

def sudo(args, **kwargs):
        return r(["sudo"] + args, **kwargs)

def chroot(path, args, **kwargs):
    sudo(["arch-chroot", path] + args, **kwargs)

    # lazy umount /dev broke my system, for some reason, when using regular chroot with manual mounts.
    # arch-chroot seems to umount /dev correctly but sometimes fails to umount /proc (it simply stays active after arch-chroot).
    # however, we can manually "umount --lazy /proc" without breaking our system. so we do just that.
    sudo(["umount", "--lazy", "--quiet", path / "proc"], ignore_error=True, **kwargs)

def get(args, **kwargs):
    log(light_cyan("get"), ' '.join(str(arg) for arg in args))
    return subprocess.check_output(args, **kwargs).decode('utf-8').rstrip()

# obtain disk usage in bytes
def du(path, **kwargs):
    return int(get(['sudo', 'du','--summarize', '--bytes', path], **kwargs).split()[0])

# create output directory
# TODO error handling in case creating dir fails
out_dir.mkdir(exist_ok=True, parents=True)

# set up data dir. we run pacstrap here. this should be owned by root to avoid pacman reporting warning.
chroot_fs = out_dir / "chroot-fs"; sudo(["mkdir", chroot_fs])

# grub-install will insist that the target location is a FAT partition.
# but we need the full size of /boot folder before we can create the partition.
# so we create a temporary image file first and put the grub stuff there
grub_tmp = out_dir / "grub-tmp.img"
r(["truncate", "--size=128M", grub_tmp])
r(["mkfs.vfat", grub_tmp])
atexit.register(r, ["rm", grub_tmp])

# create boot directory
chroot_boot = chroot_fs / "boot"
sudo(["mkdir", chroot_boot])

# mount grub image file. this needs to be unmounted before program exit.
# but we do safety "--quiet" umount in case of premature program exit (aka "error").
sudo(["mount", grub_tmp, chroot_boot])
atexit.register(sudo, ["umount", "--lazy", "--quiet", chroot_boot], ignore_error=True)

# run pacstrap
sudo(["pacstrap", "-cGM", chroot_fs] + packages)

# obtain "month-year" for bootloader id
import datetime
year = datetime.datetime.now().year
month = datetime.datetime.now().month
month_year = f"{'{:02}'.format(month)}-{year}"

# install grub. this one is only to obtain the correct size for boot partition
# we run grub-install "for real" a second time further below
chroot(chroot_fs,
    [
        "grub-install",
        "--target=x86_64-efi",
        "--efi-directory=/boot",
        f"--bootloader-id=\"Efly Live {month_year} [GRUB]\"",
        "--recheck",
        "--removable"
    ])

chroot(chroot_fs, ["pacman-key", "--init"])
chroot(chroot_fs, ["pacman-key", "--populate"])

# copy user-defined filesystem data
extra_files = profile_dir / "extra"
if extra_files.is_dir():
    sudo(["cp", "--recursive", "--no-target-directory", extra_files, chroot_fs])

# execute image customization script, if it exists
postinst_script = profile_dir / "postinst"
if postinst_script.is_file():
    # copy files
    sudo(["cp", postinst_script, chroot_fs])
    sudo(["chmod", "+x", chroot_fs / "postinst"])

    # exec postinst inside chroot
    chroot(chroot_fs, ["/postinst"])

    # cleanup files
    sudo(["rm", chroot_fs / "postinst"])

# hop into a shell, if requested by the user
if flag_shell:
    if (chroot_fs / "bin" / "fish").is_file():
        chroot(chroot_fs, ["/bin/fish", "--private"]) # launch fish but do not store any history
    elif (chroot_fs / "bin" / "bash").is_file():
        chroot(chroot_fs, ["/bin/bash"])
    elif (chroot_fs / "bin" / "sh").is_file():
        chroot(chroot_fs, ["/bin/sh"])
    else:
        error('cli flag "--shell" was specified but could not find a shell at /bin/fish, /bin/bash or /bin/sh')
        exit(1)

# calculate size of boot partition
boot_size_B = du(chroot_fs / "boot")
boot_size_M = boot_size_B / 1024 / 1024
boot_size_M = math.ceil(boot_size_M)
boot_size_M = boot_size_M + 2 # two extra MiB for boot partition. for file system metadata etc.
boot_size_M = max(boot_size_M, cli_efi_size_M)
info(f"/boot size: {boot_size_M}M")

# going to create squashfs now. need to exclude data of boot partition from that.
sudo(["umount", "--lazy", chroot_boot])

# create squashfs
efly_live_sfs = out_dir / "efly-live.sfs"
if efly_live_sfs.is_file():
    info(f"skipping mksquashfs. squashfs file already exists: {efly_live_sfs}")
else:
    # Creating a highly compressed SquashFS from a folder
    # https://techoverflow.net/2013/01/11/creating-a-highly-compressed-squashfs-from-a-folder/
    sudo(["mksquashfs", chroot_fs, efly_live_sfs, "-b", "1048576", "-comp", "xz", "-Xdict-size", "100%"])

    # https://unix.stackexchange.com/questions/256898/squashfs-minimal-compression
    #sudo(["mksquashfs", chroot_fs, efly_live_sfs, "-comp", "lz4"])

# calculate size of squashfs partition
sfs_size_B = efly_live_sfs.stat().st_size
sfs_size_M = sfs_size_B / 1024 / 1024
sfs_size_M = math.ceil(sfs_size_M)
info(f"sfs size: {sfs_size_M}M")

# initial size for ext4  on the image. will expand to full size of USB stick on first boot.
ext4_size_M = max(4, cli_overlay_size_M)

# GUID partition table takes 1MiB
gpt_size_M = 1

# we are now ready to create the final image
efly_live_img = out_dir / "efly-live.img"
# need +1 extra M for some reason here; otherwise the 3rd partition won't fit
r(["truncate", f"--size={gpt_size_M + boot_size_M + sfs_size_M + ext4_size_M + 1}M", efly_live_img])

# create partitions using sgdisk
r(["sgdisk", f"--new=1:0:+{boot_size_M}M", "--typecode", "1:EF00", "--change-name", "1:efly-boot", efly_live_img]); print()
r(["sgdisk", f"--new=2:0:+{sfs_size_M}M", "--change-name", "2:efly-squash", efly_live_img]); print()
r(["sgdisk", f"--new=3:0:+{ext4_size_M}M", "--change-name", "3:efly-overlay", efly_live_img]); print()
r(["sgdisk", "--print", efly_live_img]); print()

# set up loop device
loop = get(["sudo", "losetup", "--show", "--find", "--partscan", efly_live_img])
info(f"loop: {loop}")
atexit.register(sudo, ["losetup", "--detach", loop])

# initialize partitions
sudo(["mkfs.vfat", f"{loop}p1"])
sudo(["cp", efly_live_sfs, f"{loop}p2"])
sudo(["mkfs.ext4", f"{loop}p3"])

# helper dir for mounting image partitions
sudo(["mkdir", out_dir / "mnt"]); atexit.register(sudo, ["rmdir", out_dir / "mnt"])

# create mount point, do the mount and cleanup at the end.
def cleanup_mount(from_, to):
    sudo(["mkdir", to]); atexit.register(sudo, ["rmdir", to])
    sudo(["mount", from_, to]); atexit.register(sudo, ["umount", to])

# mount image partitions
mnt = out_dir / "mnt"
cleanup_mount(f"{loop}p1", mnt / "loop1"); efi = mnt / "loop1"
cleanup_mount(f"{loop}p2", mnt / "loop2"); lower = mnt / "loop2"
cleanup_mount(f"{loop}p3", mnt / "loop3"); overlay = mnt / "loop3"; upper = overlay / "upper"; work = overlay / "work"

# copy helper /boot to real /boot
cleanup_mount(grub_tmp, mnt / "boot")
sudo(["cp", "--recursive", "--no-target-directory", mnt / "boot", efi])

# create overlay "upper" and "work". they will be cleared at the end using atexit (likely they are empty anyway).
sudo(["mkdir", upper]); atexit.register(sudo, ["mkdir", upper]); atexit.register(sudo, ["rm", "--recursive", upper])
sudo(["mkdir", work]); atexit.register(sudo, ["mkdir", work]); atexit.register(sudo, ["rm", "--recursive", work])

# mount overlayfs
root = mnt / "root"
sudo(["mkdir", root]); atexit.register(sudo, ["rmdir", root])
sudo(["mount", "-t", "overlay", "-o", f"lowerdir={lower},upperdir={upper},workdir={work}", "none", root])
atexit.register(sudo, ["umount", root])

# we installed grub before to get the right size for the boot partition.
# but we actually need to install it relative to the obtained loop device, which we have only now.
# so we install it a second time here.

# remount boot partition and clear grub directory
boot = root / "boot"
sudo(["mount", "--bind", efi, boot]); atexit.register(sudo, ["umount", boot])
sudo(["rm", "--recursive", boot / "grub"])

# run grub-install
chroot(root, [
        "grub-install",
        "--target=x86_64-efi",
        "--efi-directory=/boot",
        f'--bootloader-id="Efly Live {month_year} [GRUB]"',
        "--recheck",
        "--removable", loop])

# copy grub config
sudo(["cp", profile_dir / "grub.cfg", boot / "grub"])

info("Running cleanup code before program exit.")
