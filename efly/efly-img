#!/usr/bin/python

usage = f"""
Usage: efly img [options]

Create raw disk images for live systems bootable from a USB flash drive.
The live system has persistent storage and will retain changes after reboots.

General Options:
  -h --help                  Show this screen.

Size Options:                Unit in M, G or T (KiB, MiB, GiB, TiB resp.) - Example: 128M
  --efi-size <size>          Set size of the EFI boot partition.
  --overlay-size <size>      Set initial size of overlay partition. Will still auto-expand on first boot.
""".lstrip().rstrip()

import os, subprocess, atexit, sys, re, math
from pathlib import Path

script_dir = Path(os.path.dirname(os.path.realpath(__file__)))

def info(msg):
    print(f"[info] {msg}")

def error(msg):
    print(f"[error] {msg}")

# https://stackoverflow.com/questions/33341000/extract-numbers-and-size-information-kb-mb-etc-from-a-string-in-python
size_regex = re.compile(r'(\d+(?:\.\d+)?)\s*([bkmgtp]?)', re.IGNORECASE)
size_order = ['b', 'k', 'm', 'g', 't', 'p']
def parse_size(size_string): # parse size string and return size in bytes
    match = size_regex.findall(size_string)
    if not match:
            raise Exception(f'invalid size: "{size_string}"')
    value, unit = match[0]
    unit = unit if unit else "b" # unit is optional. default is byte.
    return int(float(value) * (1024**size_order.index(unit.lower())))

# parse cli
cli_efi_size_M = -1
cli_overlay_size_M = -1
args = sys.argv[1:]
while args and args[0].startswith("-"):
    if args[0] == "-v" or args[0] == "--version":
        print(version)
        exit(0)

    if args[0] == "-h" or args[0] == "--help":
        print(usage)
        exit(0)

    if args[0] == "--efi-size":
        if len(args) < 2:
            error('missing argument for cli flag "--efi-size".')
            exit(1)

        try:
            cli_efi_size_B = parse_size(args[1])
            cli_efi_size_M = math.ceil(cli_efi_size_B / 1024 / 1024)
            info(f'will use at least {cli_efi_size_M}MiB for EFI boot partition')
        except Exception as e:
            error(f'invalid efi size: "{args[1]}"')
            exit(1)

        args = args[2:]
        continue

    if args[0] == "--overlay-size":
        if len(args) < 2:
            error('missing argument for cli flag "--overlay-size".')
            exit(1)

        try:
            cli_overlay_size_B = parse_size(args[1])
            cli_overlay_size_M = math.ceil(cli_overlay_size_B / 1024 / 1024)
            info(f'will use at least {cli_overlay_size_M}MiB for overlay partition')
        except Exception as e:
            error(f'invalid overlay size: "{args[1]}"')
            exit(1)

        args = args[2:]
        continue

    error(f'unknown cli flag: "{args[0]}"')
    exit(1)

# list of required shell commands together with their corresponding packages
cmd2pkg = [
    ("arch-chroot", "arch-install-scripts"),
    ("mkfs.vfat", "dosfstools"),
    ("mkfs.ext4", "e2fsprogs"),
    ("pacstrap", "arch-install-scripts"),
    ("sgdisk", "gptfdisk"),
    ("sudo", "sudo")]

# check for presence of required shell commands
from shutil import which
missing_pkg = False
for cmd, pkg in cmd2pkg:
    if which(cmd) is None:
        error(f"missing shell command '{cmd}'. if running arch linux, install with: pacman --sync {pkg}")
        missing_pkg = True

# abort if we are missing some shell commands
if missing_pkg:
    error("exiting due to missing shell command.")
    exit(1)

# check if config dir is present
img_dir = script_dir.parent / "img"
if not img_dir.is_dir():
    error(f"config folder not present: {img_dir}")
    exit(1)

# check for presence of package list
package_txt = img_dir / "packages.txt"
if not package_txt.is_file():
    error(f"package file not found: {packages_txt}")
    exit(1)

# read and parse list of packages
packages = []
with open(package_txt) as lines:
    for line in lines:
        line = line.rstrip()
        if len(line) == 0:
            continue

        line = line.split('#')[0]
        if len(line) == 0:
            continue

        line = line.split(' ')
        for pkg in line:
            if len(pkg) == 0:
                continue
            packages.append(pkg)

def r(args):
    print(f"[exec] {' '.join(str(arg) for arg in args)}")
    return subprocess.run(args)

def s(cmd):
    print(f"[exec] {cmd}")
    return os.system(cmd)

def sudo(args):
    if type(args) == str:
        return s(f"sudo {args}")
    else:
        return r(["sudo"] + args)

def chroot(path, args):
    sudo(["arch-chroot", path] + args)

    # lazy umount /dev broke my system, for some reason, when using regular chroot with manual mounts.
    # arch-chroot seems to umount /dev correctly but sometimes fails to umount /proc (it simply stays active after arch-chroot).
    # however, we can manually "umount --lazy /proc" without breaking our system. so we do just that.
    sudo(["umount", "--lazy", path / "proc"])

def get(args):
    print(f"[get] {' '.join(str(arg) for arg in args)}")
    return subprocess.check_output(args).decode('utf-8').rstrip()

# obtain disk usage in bytes
def du(path):
    return int(get(['sudo', 'du','--summarize', '--bytes', path]).split()[0])

# place all new data inside "out/" folder
out_dir = img_dir / "out"
out_dir.mkdir(exist_ok=True)
os.chdir(out_dir)

# set up data dir
chroot_fs = out_dir / "chroot-fs"
sudo(["mkdir", chroot_fs])

# grub-install will insist that the target location is a FAT partition.
# but we need the full size of /boot folder before we can create the partition.
# so we create a temporary image file first and put the grub stuff there
grub_tmp = out_dir / "grub-tmp.img"
r(["truncate", "--size=128M", grub_tmp])
r(["mkfs.vfat", grub_tmp])
atexit.register(r, ["rm", grub_tmp])

# mount grub image file
chroot_boot = chroot_fs / "boot"; sudo(["mkdir", chroot_boot])
sudo(["mount", grub_tmp, chroot_boot])

# run pacstrap
pacstrap_result = sudo(["pacstrap", "-cGM", chroot_fs] + packages)
if not pacstrap_result.returncode == 0:
    error(f"pacstrap returned non-zero: {pacstrap_result.returncode}")
    exit(1)

# obtain "month-year" for bootloader id
import datetime
year = datetime.datetime.now().year
month = datetime.datetime.now().month
month_year = f"{'{:02}'.format(month)}-{year}"

# install grub. this one is only to obtain the correct size for boot partition
# we run grub-install "for real" a second time further below
chroot(chroot_fs, ["grub-install", "--target=x86_64-efi", "--efi-directory=/boot", f"--bootloader-id=\"Efly Live {month_year} [GRUB]\"", "--recheck", "--removable"])

chroot(chroot_fs, ["pacman-key", "--init"])
chroot(chroot_fs, ["pacman-key", "--populate"])

# copy user-defined filesystem data
mkosi_extra = img_dir / "extra"
if mkosi_extra.is_dir():
    sudo(["cp", "--recursive", "--no-target-directory", mkosi_extra, chroot_fs])

# execute image customization script, if it exists
mkosi_postinst = img_dir / "postinst"
if mkosi_postinst.is_file():
    # copy files
    sudo(["cp", mkosi_postinst, chroot_fs])
    sudo(["chmod", "+x", chroot_fs / "postinst"])

    # exec postinst inside chroot
    chroot(chroot_fs, ["/postinst"])

    # cleanup files
    sudo(["rm", chroot_fs / "postinst"])

# calculate size of boot partition
boot_size_B = du(chroot_fs / "boot")
boot_size_M = boot_size_B / 1024 / 1024
boot_size_M = math.ceil(boot_size_M)
boot_size_M = boot_size_M + 2 # two extra MiB for boot partition. for file system metadata etc.
boot_size_M = max(boot_size_M, cli_efi_size_M)
print(f"/boot size: {boot_size_M}M")

# going to create squashfs now. need to exclude data of boot partition from that
sudo(["umount", "--lazy", chroot_boot])

# create squashfs
efly_live_sfs = out_dir / "efly-live.sfs"
if efly_live_sfs.is_file():
    info(f"skipping mksquashfs. squashfs file already exists: {efly_live_sfs}")
else:
    # Creating a highly compressed SquashFS from a folder
    # https://techoverflow.net/2013/01/11/creating-a-highly-compressed-squashfs-from-a-folder/
    sudo(["mksquashfs", chroot_fs, efly_live_sfs, "-b", "1048576", "-comp", "xz", "-Xdict-size", "100%"])

    # https://unix.stackexchange.com/questions/256898/squashfs-minimal-compression
    #sudo(["mksquashfs", chroot_fs, efly_live_sfs, "-comp", "lz4"])

# we are now ready to create the final image

sfs_size_B = efly_live_sfs.stat().st_size
sfs_size_M = sfs_size_B / 1024 / 1024
sfs_size_M = math.ceil(sfs_size_M)
print(f"sfs size: {sfs_size_M}M")

# initial size for ext4  on the image. will expand to full size of USB stick on first boot.
ext4_size_M = max(4, cli_overlay_size_M)

# GUID partition table takes 1MiB
gpt_size_M = 1

# need +1 extra M for some reason here; otherwise the 3rd partition won't fit
s(f"truncate --size={gpt_size_M + boot_size_M + sfs_size_M + ext4_size_M + 1}M efly-live.img")

# create partitions using sgdisk
s(f'sgdisk --new=1:0:+{boot_size_M}M --typecode 1:EF00 --change-name 1:"efly-boot" efly-live.img'); print()
s(f'sgdisk --new=2:0:+{sfs_size_M}M --change-name 2:"efly-squash" efly-live.img'); print()
s(f'sgdisk --new=3:0:+{ext4_size_M}M --change-name 3:"efly-overlay" efly-live.img'); print()
s(f"sgdisk --print efly-live.img"); print()

# set up loop device
loop = get(["sudo", "losetup", "--show", "--find", "--partscan", "efly-live.img"])
print(f"loop: {loop}")
atexit.register(sudo, f"losetup --detach {loop}")

# initialize partitions
sudo(f"mkfs.vfat {loop}p1")
sudo(f"cp efly-live.sfs {loop}p2")
sudo(f"mkfs.ext4 {loop}p3")

# helper dir for mounting image partitions
sudo("mkdir mnt/"); atexit.register(sudo, "rmdir mnt/")

# copy helper /boot to real /boot
sudo("mkdir mnt-boot/"); sudo(["mount", grub_tmp, "mnt-boot/"])
sudo(f"mount {loop}p1 mnt/")
sudo(f"cp --recursive --no-target-directory mnt-boot/ mnt/")
sudo(f"umount mnt/")
sudo("umount mnt-boot/"); sudo("rmdir mnt-boot/")

# mount squashfs partition
sudo("mkdir mnt/squashfs"); atexit.register(sudo, "rmdir mnt/squashfs")
sudo(f"mount {loop}p2 mnt/squashfs"); atexit.register(sudo, "umount mnt/squashfs")

# mount overlay partition
sudo("mkdir mnt/overlay"); atexit.register(sudo, "rmdir mnt/overlay")
sudo(f"mount {loop}p3 mnt/overlay"); atexit.register(sudo, "umount mnt/overlay")

# create overlay "upper" and "work". they will be cleared at the end using atexit.
sudo("mkdir mnt/overlay/upper"); atexit.register(sudo, "mkdir mnt/overlay/upper"); atexit.register(sudo, "rm --recursive mnt/overlay/upper")
sudo("mkdir mnt/overlay/work"); atexit.register(sudo, "mkdir mnt/overlay/work"); atexit.register(sudo, "rm --recursive mnt/overlay/work")

# mount overlayfs
sudo("mkdir mnt/root"); atexit.register(sudo, "rmdir mnt/root")
sudo(f"mount -t overlay -o lowerdir=mnt/squashfs,upperdir=mnt/overlay/upper,workdir=mnt/overlay/work none mnt/root"); atexit.register(sudo, "umount mnt/root")

# mount boot partition
sudo(f"mount {loop}p1 mnt/root/boot")
atexit.register(sudo, "umount mnt/root/boot")

# we installed grub before to get the right size for the boot partition.
# but we actually need to install it relative to the obtained loop device, which we have only now.
# so we install it a second time here.
sudo("rm --recursive mnt/root/boot/grub")
chroot(out_dir / "mnt" / "root", [
        "grub-install",
        "--target=x86_64-efi",
        "--efi-directory=/boot",
        f"--bootloader-id=\"Efly Live {month_year} [GRUB]\"",
        "--recheck",
        "--removable", loop])

# copy grub config
sudo(["cp", img_dir/ "grub.cfg", out_dir / "mnt" / "root"/ "boot" / "grub"])
